import { errors } from '@adonisjs/auth';
import jwt from 'jsonwebtoken';
import { Secret } from '@adonisjs/core/helpers';
export class JwtGuard {
    #ctx;
    #userProvider;
    #refreshTokenUserProvider;
    #options;
    #tokenName;
    constructor(ctx, userProvider, option) {
        this.#ctx = ctx;
        this.#userProvider = userProvider;
        this.#options = option;
        this.#refreshTokenUserProvider = this.#options.refreshTokenUserProvider;
        if (!this.#options.content)
            this.#options.content = (user) => ({ userId: user.getId() });
        this.#tokenName = this.#options.tokenName ?? 'token';
    }
    /**
     * A unique name for the guard driver
     */
    driverName = 'jwt';
    /**
     * A flag to know if the authentication was an attempt
     * during the current HTTP request
     */
    authenticationAttempted = false;
    /**
     * A boolean to know if the current request has
     * been authenticated
     */
    isAuthenticated = false;
    /**
     * Reference to the currently authenticated user
     */
    user;
    /**
     * Generate a JWT token for a given user.
     */
    async generate(user) {
        const providerUser = await this.#userProvider.createUserForGuard(user);
        const token = jwt.sign(this.#options.content(providerUser), this.#options.secret, this.#options.expiresIn
            ? {
                expiresIn: this.#options.expiresIn,
            }
            : {});
        if (this.#options.useCookies) {
            return this.#ctx.response.cookie(`${this.#tokenName}`, token, {
                httpOnly: true,
            });
        }
        return {
            type: 'bearer',
            token: token,
            expiresIn: this.#options.expiresIn,
        };
    }
    /**
     * Authenticate the current HTTP request and return
     * the user instance if there is a valid JWT token
     * or throw an exception
     */
    async authenticate() {
        /**
         * Avoid re-authentication when it has been done already
         * for the given request
         */
        if (this.authenticationAttempted) {
            return this.getUserOrFail();
        }
        this.authenticationAttempted = true;
        const cookieHeader = this.#ctx.request.request.headers.cookie;
        let token;
        /**
         * If cookies are enabled, then read the token from the cookies
         */
        if (cookieHeader) {
            const regex = new RegExp(`${this.#tokenName}=([^;]*)`);
            token =
                this.#ctx.request.cookie(`${this.#tokenName}`) ??
                    (this.#ctx.request.request.headers.cookie.match(regex) || [])[1];
        }
        /**
         * If token is missing on cookies, then try to read it from the header authorization
         */
        if (!token) {
            /**
             * Ensure the auth header exists
             */
            const authHeader = this.#ctx.request.header('authorization');
            if (!authHeader) {
                throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                    guardDriverName: this.driverName,
                });
            }
            /**
             * Split the header value and read the token from it
             */
            ;
            [, token] = authHeader.split('Bearer ');
            if (!token) {
                throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                    guardDriverName: this.driverName,
                });
            }
        }
        /**
         * Verify token
         */
        let payload;
        try {
            payload = jwt.verify(token, this.#options.secret);
        }
        catch (error) {
            throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                guardDriverName: this.driverName,
            });
        }
        if (typeof payload !== 'object' || !('userId' in payload)) {
            throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                guardDriverName: this.driverName,
            });
        }
        /**
         * Fetch the user by user ID and save a reference to it
         */
        const providerUser = await this.#userProvider.findById(payload.userId);
        if (!providerUser) {
            throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                guardDriverName: this.driverName,
            });
        }
        this.isAuthenticated = true;
        this.user = providerUser.getOriginal();
        this.user.currentToken = token;
        return this.getUserOrFail();
    }
    async authenticateWithRefreshToken(name) {
        /**
         * Avoid re-authentication when it has been done already
         * for the given request
         */
        if (this.authenticationAttempted) {
            return this.getUserOrFail();
        }
        this.authenticationAttempted = true;
        /**
         * Ensure the refresh token user provider is defined
         */
        if (!this.#refreshTokenUserProvider) {
            throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                guardDriverName: this.driverName,
            });
        }
        /**
         * Ensure the auth header exists
         */
        const authHeader = this.#ctx.request.header('authorization');
        if (!authHeader) {
            throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                guardDriverName: this.driverName,
            });
        }
        /**
         * Split the header value and read the token from it
         */
        const [, refreshToken] = authHeader.split('Bearer ');
        if (!refreshToken) {
            throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                guardDriverName: this.driverName,
            });
        }
        const accessToken = await this.#refreshTokenUserProvider.verifyToken(new Secret(refreshToken));
        if (!accessToken) {
            throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                guardDriverName: this.driverName,
            });
        }
        /**
         * Fetch the user by user ID
         */
        const providerUser = await this.#refreshTokenUserProvider.findById(accessToken.tokenableId);
        if (!providerUser) {
            throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                guardDriverName: this.driverName,
            });
        }
        this.isAuthenticated = true;
        this.user = providerUser.getOriginal();
        /**
         * Get the same abilities for the new refresh token
         */
        const abilities = accessToken.abilities;
        /**
         * Delete the refresh token from the database
         */
        const isDeleted = await this.#refreshTokenUserProvider.invalidateToken(new Secret(refreshToken));
        if (!isDeleted) {
            throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                guardDriverName: this.driverName,
            });
        }
        const newRefreshToken = await this.#refreshTokenUserProvider.createToken(this.user, abilities, {
            name,
        });
        if (!newRefreshToken.value) {
            throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                guardDriverName: this.driverName,
            });
        }
        this.user.currentToken = newRefreshToken.value?.release();
        return this.getUserOrFail();
    }
    /**
     * Same as authenticate, but does not throw an exception
     */
    async check() {
        try {
            await this.authenticate();
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * Returns the authenticated user or throws an error
     */
    getUserOrFail() {
        if (!this.user) {
            throw new errors.E_UNAUTHORIZED_ACCESS('Unauthorized access', {
                guardDriverName: this.driverName,
            });
        }
        return this.user;
    }
    /**
     * This method is called by Japa during testing when "loginAs"
     * method is used to login the user.
     */
    async authenticateAsClient(user) {
        const token = await this.generate(user);
        return {
            headers: {
                authorization: `Bearer ${this.#options.useCookies ? token : token.token}`,
            },
        };
    }
}
